<?php
/**
 * WorkflowApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * TruEdit REST API
 *
 * Welcome to the TruEdit Platform REST API Reference! You can use this REST API to develop integrations between TruEdit and other applications or script interactions with TruEdit.
 *
 * OpenAPI spec version: 1
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * WorkflowApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class WorkflowApi {

	/**
	 * @var ClientInterface
	 */
	protected $client;

	/**
	 * @var Configuration
	 */
	protected $config;

	/**
	 * @param ClientInterface $client
	 * @param Configuration   $config
	 * @param HeaderSelector  $selector
	 */
	public function __construct(
		ClientInterface $client = null,
		Configuration $config = null,
		HeaderSelector $selector = null
	) {
		$this->client         = $client ?: new Client();
		$this->config         = $config ?: new Configuration();
		$this->headerSelector = $selector ?: new HeaderSelector();
	}

	/**
	 * @return Configuration
	 */
	public function getConfig() {
		return $this->config;
	}

	/**
	 * Operation createNewWorkflowsUsingPOST
	 *
	 * Create one or more Workflows
	 *
	 * @param  \Swagger\Client\Model\WorkflowV1ListTO $new_workflows newWorkflows (required)
	 * @param  string $x_api_key x_api_key (optional)
	 * @param  string $x_app_api_key x_app_api_key (optional)
	 * @param  string $accept_language accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return \Swagger\Client\Model\API1ResultListResponseWorkflowV1TO_
	 */
	public function createNewWorkflowsUsingPOST( $new_workflows, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		list($response) = $this->createNewWorkflowsUsingPOSTWithHttpInfo( $new_workflows, $x_api_key, $x_app_api_key, $accept_language );
		return $response;
	}

	/**
	 * Operation createNewWorkflowsUsingPOSTWithHttpInfo
	 *
	 * Create one or more Workflows
	 *
	 * @param  \Swagger\Client\Model\WorkflowV1ListTO $new_workflows newWorkflows (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return array of \Swagger\Client\Model\API1ResultListResponseWorkflowV1TO_, HTTP status code, HTTP response headers (array of strings)
	 */
	public function createNewWorkflowsUsingPOSTWithHttpInfo( $new_workflows, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1ResultListResponseWorkflowV1TO_';
		$request    = $this->createNewWorkflowsUsingPOSTRequest( $new_workflows, $x_api_key, $x_app_api_key, $accept_language );

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send( $request, $options );
			} catch ( RequestException $e ) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					$e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
				);
			}

			$statusCode = $response->getStatusCode();

			if ( $statusCode < 200 || $statusCode > 299 ) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						$request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					$response->getBody()
				);
			}

			$responseBody = $response->getBody();
			if ( $returnType === '\SplFileObject' ) {
				$content = $responseBody; //stream goes to serializer
			} else {
				$content = $responseBody->getContents();
				if ( $returnType !== 'string' ) {
					$content = json_decode( $content );
				}
			}

			return [
				ObjectSerializer::deserialize( $content, $returnType, [] ),
				$response->getStatusCode(),
				$response->getHeaders(),
			];

		} catch ( ApiException $e ) {
			switch ( $e->getCode() ) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\Swagger\Client\Model\API1ResultListResponseWorkflowV1TO_',
						$e->getResponseHeaders()
					);
					$e->setResponseObject( $data );
					break;
			}
			throw $e;
		}
	}

	/**
	 * Operation createNewWorkflowsUsingPOSTAsync
	 *
	 * Create one or more Workflows
	 *
	 * @param  \Swagger\Client\Model\WorkflowV1ListTO $new_workflows newWorkflows (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function createNewWorkflowsUsingPOSTAsync( $new_workflows, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		return $this->createNewWorkflowsUsingPOSTAsyncWithHttpInfo( $new_workflows, $x_api_key, $x_app_api_key, $accept_language )
			->then(
				function ( $response ) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation createNewWorkflowsUsingPOSTAsyncWithHttpInfo
	 *
	 * Create one or more Workflows
	 *
	 * @param  \Swagger\Client\Model\WorkflowV1ListTO $new_workflows newWorkflows (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function createNewWorkflowsUsingPOSTAsyncWithHttpInfo( $new_workflows, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1ResultListResponseWorkflowV1TO_';
		$request    = $this->createNewWorkflowsUsingPOSTRequest( $new_workflows, $x_api_key, $x_app_api_key, $accept_language );

		return $this->client
			->sendAsync( $request, $this->createHttpClientOption() )
			->then(
				function ( $response ) use ( $returnType ) {
					$responseBody = $response->getBody();
					if ( $returnType === '\SplFileObject' ) {
						$content = $responseBody; //stream goes to serializer
					} else {
						$content = $responseBody->getContents();
						if ( $returnType !== 'string' ) {
							$content = json_decode( $content );
						}
					}

					return [
						ObjectSerializer::deserialize( $content, $returnType, [] ),
						$response->getStatusCode(),
						$response->getHeaders(),
					];
				},
				function ( $exception ) {
					$response   = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						$response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'createNewWorkflowsUsingPOST'
	 *
	 * @param  \Swagger\Client\Model\WorkflowV1ListTO $new_workflows newWorkflows (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	protected function createNewWorkflowsUsingPOSTRequest( $new_workflows, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		// verify the required parameter 'new_workflows' is set
		if ( $new_workflows === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $new_workflows when calling createNewWorkflowsUsingPOST'
			);
		}

		$resourcePath = '/1/workflow';
		$formParams   = [];
		$queryParams  = [];
		$headerParams = [];
		$httpBody     = '';
		$multipart    = false;

		// header params
		if ( $x_api_key !== null ) {
			$headerParams['x-api-key'] = ObjectSerializer::toHeaderValue( $x_api_key );
		}
		// header params
		if ( $x_app_api_key !== null ) {
			$headerParams['x-app-api-key'] = ObjectSerializer::toHeaderValue( $x_app_api_key );
		}
		// header params
		if ( $accept_language !== null ) {
			$headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue( $accept_language );
		}

		// body params
		$_tempBody = null;
		if ( isset( $new_workflows ) ) {
			$_tempBody = $new_workflows;
		}

		if ( $multipart ) {
			$headers = $this->headerSelector->selectHeadersForMultipart(
				[ '*/*', 'application/json' ]
			);
		} else {
			$headers = $this->headerSelector->selectHeaders(
				[ '*/*', 'application/json' ],
				[ 'application/json' ]
			);
		}

		// for model (json/xml)
		if ( isset( $_tempBody ) ) {
			// $_tempBody is the method argument, if present
			$httpBody = $_tempBody;
			// \stdClass has no __toString(), so we should encode it manually
			if ( $httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $httpBody );
			}
		} elseif ( count( $formParams ) > 0 ) {
			if ( $multipart ) {
				$multipartContents = [];
				foreach ( $formParams as $formParamName => $formParamValue ) {
					$multipartContents[] = [
						'name'     => $formParamName,
						'contents' => $formParamValue,
					];
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream( $multipartContents );

			} elseif ( $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $formParams );

			} else {
				// for HTTP post (form)
				$httpBody = \GuzzleHttp\Psr7\build_query( $formParams );
			}
		}

		$defaultHeaders = [];
		if ( $this->config->getUserAgent() ) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$query = \GuzzleHttp\Psr7\build_query( $queryParams );
		return new Request(
			'POST',
			$this->config->getHost() . $resourcePath . ( $query ? "?{$query}" : '' ),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation createTransitionsUsingPOST
	 *
	 * Create Transitions of one specified Applied Status of a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  \Swagger\Client\Model\TransitionV1ListTO $incoming_transitions incomingTransitions (required)
	 * @param  string $x_api_key x_api_key (optional)
	 * @param  string $x_app_api_key x_app_api_key (optional)
	 * @param  string $accept_language accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return \Swagger\Client\Model\API1ResultListResponseTransitionV1TO_
	 */
	public function createTransitionsUsingPOST( $workflow_id, $status_id, $incoming_transitions, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		list($response) = $this->createTransitionsUsingPOSTWithHttpInfo( $workflow_id, $status_id, $incoming_transitions, $x_api_key, $x_app_api_key, $accept_language );
		return $response;
	}

	/**
	 * Operation createTransitionsUsingPOSTWithHttpInfo
	 *
	 * Create Transitions of one specified Applied Status of a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  \Swagger\Client\Model\TransitionV1ListTO $incoming_transitions incomingTransitions (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return array of \Swagger\Client\Model\API1ResultListResponseTransitionV1TO_, HTTP status code, HTTP response headers (array of strings)
	 */
	public function createTransitionsUsingPOSTWithHttpInfo( $workflow_id, $status_id, $incoming_transitions, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1ResultListResponseTransitionV1TO_';
		$request    = $this->createTransitionsUsingPOSTRequest( $workflow_id, $status_id, $incoming_transitions, $x_api_key, $x_app_api_key, $accept_language );

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send( $request, $options );
			} catch ( RequestException $e ) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					$e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
				);
			}

			$statusCode = $response->getStatusCode();

			if ( $statusCode < 200 || $statusCode > 299 ) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						$request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					$response->getBody()
				);
			}

			$responseBody = $response->getBody();
			if ( $returnType === '\SplFileObject' ) {
				$content = $responseBody; //stream goes to serializer
			} else {
				$content = $responseBody->getContents();
				if ( $returnType !== 'string' ) {
					$content = json_decode( $content );
				}
			}

			return [
				ObjectSerializer::deserialize( $content, $returnType, [] ),
				$response->getStatusCode(),
				$response->getHeaders(),
			];

		} catch ( ApiException $e ) {
			switch ( $e->getCode() ) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\Swagger\Client\Model\API1ResultListResponseTransitionV1TO_',
						$e->getResponseHeaders()
					);
					$e->setResponseObject( $data );
					break;
			}
			throw $e;
		}
	}

	/**
	 * Operation createTransitionsUsingPOSTAsync
	 *
	 * Create Transitions of one specified Applied Status of a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  \Swagger\Client\Model\TransitionV1ListTO $incoming_transitions incomingTransitions (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function createTransitionsUsingPOSTAsync( $workflow_id, $status_id, $incoming_transitions, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		return $this->createTransitionsUsingPOSTAsyncWithHttpInfo( $workflow_id, $status_id, $incoming_transitions, $x_api_key, $x_app_api_key, $accept_language )
			->then(
				function ( $response ) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation createTransitionsUsingPOSTAsyncWithHttpInfo
	 *
	 * Create Transitions of one specified Applied Status of a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  \Swagger\Client\Model\TransitionV1ListTO $incoming_transitions incomingTransitions (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function createTransitionsUsingPOSTAsyncWithHttpInfo( $workflow_id, $status_id, $incoming_transitions, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1ResultListResponseTransitionV1TO_';
		$request    = $this->createTransitionsUsingPOSTRequest( $workflow_id, $status_id, $incoming_transitions, $x_api_key, $x_app_api_key, $accept_language );

		return $this->client
			->sendAsync( $request, $this->createHttpClientOption() )
			->then(
				function ( $response ) use ( $returnType ) {
					$responseBody = $response->getBody();
					if ( $returnType === '\SplFileObject' ) {
						$content = $responseBody; //stream goes to serializer
					} else {
						$content = $responseBody->getContents();
						if ( $returnType !== 'string' ) {
							$content = json_decode( $content );
						}
					}

					return [
						ObjectSerializer::deserialize( $content, $returnType, [] ),
						$response->getStatusCode(),
						$response->getHeaders(),
					];
				},
				function ( $exception ) {
					$response   = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						$response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'createTransitionsUsingPOST'
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  \Swagger\Client\Model\TransitionV1ListTO $incoming_transitions incomingTransitions (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	protected function createTransitionsUsingPOSTRequest( $workflow_id, $status_id, $incoming_transitions, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		// verify the required parameter 'workflow_id' is set
		if ( $workflow_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $workflow_id when calling createTransitionsUsingPOST'
			);
		}
		// verify the required parameter 'status_id' is set
		if ( $status_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $status_id when calling createTransitionsUsingPOST'
			);
		}
		// verify the required parameter 'incoming_transitions' is set
		if ( $incoming_transitions === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $incoming_transitions when calling createTransitionsUsingPOST'
			);
		}

		$resourcePath = '/1/workflow/{workflowID}/status/{statusID}/transition';
		$formParams   = [];
		$queryParams  = [];
		$headerParams = [];
		$httpBody     = '';
		$multipart    = false;

		// header params
		if ( $x_api_key !== null ) {
			$headerParams['x-api-key'] = ObjectSerializer::toHeaderValue( $x_api_key );
		}
		// header params
		if ( $x_app_api_key !== null ) {
			$headerParams['x-app-api-key'] = ObjectSerializer::toHeaderValue( $x_app_api_key );
		}
		// header params
		if ( $accept_language !== null ) {
			$headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue( $accept_language );
		}

		// path params
		if ( $workflow_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'workflowID' . '}',
				ObjectSerializer::toPathValue( $workflow_id ),
				$resourcePath
			);
		}
		// path params
		if ( $status_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'statusID' . '}',
				ObjectSerializer::toPathValue( $status_id ),
				$resourcePath
			);
		}

		// body params
		$_tempBody = null;
		if ( isset( $incoming_transitions ) ) {
			$_tempBody = $incoming_transitions;
		}

		if ( $multipart ) {
			$headers = $this->headerSelector->selectHeadersForMultipart(
				[ '*/*', 'application/json' ]
			);
		} else {
			$headers = $this->headerSelector->selectHeaders(
				[ '*/*', 'application/json' ],
				[ 'application/json' ]
			);
		}

		// for model (json/xml)
		if ( isset( $_tempBody ) ) {
			// $_tempBody is the method argument, if present
			$httpBody = $_tempBody;
			// \stdClass has no __toString(), so we should encode it manually
			if ( $httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $httpBody );
			}
		} elseif ( count( $formParams ) > 0 ) {
			if ( $multipart ) {
				$multipartContents = [];
				foreach ( $formParams as $formParamName => $formParamValue ) {
					$multipartContents[] = [
						'name'     => $formParamName,
						'contents' => $formParamValue,
					];
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream( $multipartContents );

			} elseif ( $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $formParams );

			} else {
				// for HTTP post (form)
				$httpBody = \GuzzleHttp\Psr7\build_query( $formParams );
			}
		}

		$defaultHeaders = [];
		if ( $this->config->getUserAgent() ) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$query = \GuzzleHttp\Psr7\build_query( $queryParams );
		return new Request(
			'POST',
			$this->config->getHost() . $resourcePath . ( $query ? "?{$query}" : '' ),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation createWorkstepsUsingPOST
	 *
	 * Create one or more Applied Statuses in a specified Workflow
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  \Swagger\Client\Model\AppliedStatusV1ListTO $incoming_worksteps incomingWorksteps (required)
	 * @param  string $x_api_key x_api_key (optional)
	 * @param  string $x_app_api_key x_app_api_key (optional)
	 * @param  string $accept_language accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return \Swagger\Client\Model\API1ResultListResponseAppliedStatusV1TO_
	 */
	public function createWorkstepsUsingPOST( $workflow_id, $incoming_worksteps, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		list($response) = $this->createWorkstepsUsingPOSTWithHttpInfo( $workflow_id, $incoming_worksteps, $x_api_key, $x_app_api_key, $accept_language );
		return $response;
	}

	/**
	 * Operation createWorkstepsUsingPOSTWithHttpInfo
	 *
	 * Create one or more Applied Statuses in a specified Workflow
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  \Swagger\Client\Model\AppliedStatusV1ListTO $incoming_worksteps incomingWorksteps (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return array of \Swagger\Client\Model\API1ResultListResponseAppliedStatusV1TO_, HTTP status code, HTTP response headers (array of strings)
	 */
	public function createWorkstepsUsingPOSTWithHttpInfo( $workflow_id, $incoming_worksteps, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1ResultListResponseAppliedStatusV1TO_';
		$request    = $this->createWorkstepsUsingPOSTRequest( $workflow_id, $incoming_worksteps, $x_api_key, $x_app_api_key, $accept_language );

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send( $request, $options );
			} catch ( RequestException $e ) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					$e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
				);
			}

			$statusCode = $response->getStatusCode();

			if ( $statusCode < 200 || $statusCode > 299 ) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						$request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					$response->getBody()
				);
			}

			$responseBody = $response->getBody();
			if ( $returnType === '\SplFileObject' ) {
				$content = $responseBody; //stream goes to serializer
			} else {
				$content = $responseBody->getContents();
				if ( $returnType !== 'string' ) {
					$content = json_decode( $content );
				}
			}

			return [
				ObjectSerializer::deserialize( $content, $returnType, [] ),
				$response->getStatusCode(),
				$response->getHeaders(),
			];

		} catch ( ApiException $e ) {
			switch ( $e->getCode() ) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\Swagger\Client\Model\API1ResultListResponseAppliedStatusV1TO_',
						$e->getResponseHeaders()
					);
					$e->setResponseObject( $data );
					break;
			}
			throw $e;
		}
	}

	/**
	 * Operation createWorkstepsUsingPOSTAsync
	 *
	 * Create one or more Applied Statuses in a specified Workflow
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  \Swagger\Client\Model\AppliedStatusV1ListTO $incoming_worksteps incomingWorksteps (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function createWorkstepsUsingPOSTAsync( $workflow_id, $incoming_worksteps, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		return $this->createWorkstepsUsingPOSTAsyncWithHttpInfo( $workflow_id, $incoming_worksteps, $x_api_key, $x_app_api_key, $accept_language )
			->then(
				function ( $response ) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation createWorkstepsUsingPOSTAsyncWithHttpInfo
	 *
	 * Create one or more Applied Statuses in a specified Workflow
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  \Swagger\Client\Model\AppliedStatusV1ListTO $incoming_worksteps incomingWorksteps (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function createWorkstepsUsingPOSTAsyncWithHttpInfo( $workflow_id, $incoming_worksteps, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1ResultListResponseAppliedStatusV1TO_';
		$request    = $this->createWorkstepsUsingPOSTRequest( $workflow_id, $incoming_worksteps, $x_api_key, $x_app_api_key, $accept_language );

		return $this->client
			->sendAsync( $request, $this->createHttpClientOption() )
			->then(
				function ( $response ) use ( $returnType ) {
					$responseBody = $response->getBody();
					if ( $returnType === '\SplFileObject' ) {
						$content = $responseBody; //stream goes to serializer
					} else {
						$content = $responseBody->getContents();
						if ( $returnType !== 'string' ) {
							$content = json_decode( $content );
						}
					}

					return [
						ObjectSerializer::deserialize( $content, $returnType, [] ),
						$response->getStatusCode(),
						$response->getHeaders(),
					];
				},
				function ( $exception ) {
					$response   = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						$response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'createWorkstepsUsingPOST'
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  \Swagger\Client\Model\AppliedStatusV1ListTO $incoming_worksteps incomingWorksteps (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	protected function createWorkstepsUsingPOSTRequest( $workflow_id, $incoming_worksteps, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		// verify the required parameter 'workflow_id' is set
		if ( $workflow_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $workflow_id when calling createWorkstepsUsingPOST'
			);
		}
		// verify the required parameter 'incoming_worksteps' is set
		if ( $incoming_worksteps === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $incoming_worksteps when calling createWorkstepsUsingPOST'
			);
		}

		$resourcePath = '/1/workflow/{workflowID}/status';
		$formParams   = [];
		$queryParams  = [];
		$headerParams = [];
		$httpBody     = '';
		$multipart    = false;

		// header params
		if ( $x_api_key !== null ) {
			$headerParams['x-api-key'] = ObjectSerializer::toHeaderValue( $x_api_key );
		}
		// header params
		if ( $x_app_api_key !== null ) {
			$headerParams['x-app-api-key'] = ObjectSerializer::toHeaderValue( $x_app_api_key );
		}
		// header params
		if ( $accept_language !== null ) {
			$headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue( $accept_language );
		}

		// path params
		if ( $workflow_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'workflowID' . '}',
				ObjectSerializer::toPathValue( $workflow_id ),
				$resourcePath
			);
		}

		// body params
		$_tempBody = null;
		if ( isset( $incoming_worksteps ) ) {
			$_tempBody = $incoming_worksteps;
		}

		if ( $multipart ) {
			$headers = $this->headerSelector->selectHeadersForMultipart(
				[ '*/*', 'application/json' ]
			);
		} else {
			$headers = $this->headerSelector->selectHeaders(
				[ '*/*', 'application/json' ],
				[ 'application/json' ]
			);
		}

		// for model (json/xml)
		if ( isset( $_tempBody ) ) {
			// $_tempBody is the method argument, if present
			$httpBody = $_tempBody;
			// \stdClass has no __toString(), so we should encode it manually
			if ( $httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $httpBody );
			}
		} elseif ( count( $formParams ) > 0 ) {
			if ( $multipart ) {
				$multipartContents = [];
				foreach ( $formParams as $formParamName => $formParamValue ) {
					$multipartContents[] = [
						'name'     => $formParamName,
						'contents' => $formParamValue,
					];
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream( $multipartContents );

			} elseif ( $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $formParams );

			} else {
				// for HTTP post (form)
				$httpBody = \GuzzleHttp\Psr7\build_query( $formParams );
			}
		}

		$defaultHeaders = [];
		if ( $this->config->getUserAgent() ) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$query = \GuzzleHttp\Psr7\build_query( $queryParams );
		return new Request(
			'POST',
			$this->config->getHost() . $resourcePath . ( $query ? "?{$query}" : '' ),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation deleteOneTransitionUsingDELETE
	 *
	 * Delete one Transition of one specified Applied Status of a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  int $destination_id destinationID (required)
	 * @param  string $x_api_key x_api_key (optional)
	 * @param  string $x_app_api_key x_app_api_key (optional)
	 * @param  string $accept_language accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return \Swagger\Client\Model\API1ResponseMessage
	 */
	public function deleteOneTransitionUsingDELETE( $workflow_id, $status_id, $destination_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		list($response) = $this->deleteOneTransitionUsingDELETEWithHttpInfo( $workflow_id, $status_id, $destination_id, $x_api_key, $x_app_api_key, $accept_language );
		return $response;
	}

	/**
	 * Operation deleteOneTransitionUsingDELETEWithHttpInfo
	 *
	 * Delete one Transition of one specified Applied Status of a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  int $destination_id destinationID (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return array of \Swagger\Client\Model\API1ResponseMessage, HTTP status code, HTTP response headers (array of strings)
	 */
	public function deleteOneTransitionUsingDELETEWithHttpInfo( $workflow_id, $status_id, $destination_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1ResponseMessage';
		$request    = $this->deleteOneTransitionUsingDELETERequest( $workflow_id, $status_id, $destination_id, $x_api_key, $x_app_api_key, $accept_language );

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send( $request, $options );
			} catch ( RequestException $e ) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					$e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
				);
			}

			$statusCode = $response->getStatusCode();

			if ( $statusCode < 200 || $statusCode > 299 ) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						$request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					$response->getBody()
				);
			}

			$responseBody = $response->getBody();
			if ( $returnType === '\SplFileObject' ) {
				$content = $responseBody; //stream goes to serializer
			} else {
				$content = $responseBody->getContents();
				if ( $returnType !== 'string' ) {
					$content = json_decode( $content );
				}
			}

			return [
				ObjectSerializer::deserialize( $content, $returnType, [] ),
				$response->getStatusCode(),
				$response->getHeaders(),
			];

		} catch ( ApiException $e ) {
			switch ( $e->getCode() ) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\Swagger\Client\Model\API1ResponseMessage',
						$e->getResponseHeaders()
					);
					$e->setResponseObject( $data );
					break;
			}
			throw $e;
		}
	}

	/**
	 * Operation deleteOneTransitionUsingDELETEAsync
	 *
	 * Delete one Transition of one specified Applied Status of a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  int $destination_id destinationID (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteOneTransitionUsingDELETEAsync( $workflow_id, $status_id, $destination_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		return $this->deleteOneTransitionUsingDELETEAsyncWithHttpInfo( $workflow_id, $status_id, $destination_id, $x_api_key, $x_app_api_key, $accept_language )
			->then(
				function ( $response ) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation deleteOneTransitionUsingDELETEAsyncWithHttpInfo
	 *
	 * Delete one Transition of one specified Applied Status of a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  int $destination_id destinationID (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteOneTransitionUsingDELETEAsyncWithHttpInfo( $workflow_id, $status_id, $destination_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1ResponseMessage';
		$request    = $this->deleteOneTransitionUsingDELETERequest( $workflow_id, $status_id, $destination_id, $x_api_key, $x_app_api_key, $accept_language );

		return $this->client
			->sendAsync( $request, $this->createHttpClientOption() )
			->then(
				function ( $response ) use ( $returnType ) {
					$responseBody = $response->getBody();
					if ( $returnType === '\SplFileObject' ) {
						$content = $responseBody; //stream goes to serializer
					} else {
						$content = $responseBody->getContents();
						if ( $returnType !== 'string' ) {
							$content = json_decode( $content );
						}
					}

					return [
						ObjectSerializer::deserialize( $content, $returnType, [] ),
						$response->getStatusCode(),
						$response->getHeaders(),
					];
				},
				function ( $exception ) {
					$response   = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						$response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'deleteOneTransitionUsingDELETE'
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  int $destination_id destinationID (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	protected function deleteOneTransitionUsingDELETERequest( $workflow_id, $status_id, $destination_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		// verify the required parameter 'workflow_id' is set
		if ( $workflow_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $workflow_id when calling deleteOneTransitionUsingDELETE'
			);
		}
		// verify the required parameter 'status_id' is set
		if ( $status_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $status_id when calling deleteOneTransitionUsingDELETE'
			);
		}
		// verify the required parameter 'destination_id' is set
		if ( $destination_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $destination_id when calling deleteOneTransitionUsingDELETE'
			);
		}

		$resourcePath = '/1/workflow/{workflowID}/status/{statusID}/transition/{destinationID}';
		$formParams   = [];
		$queryParams  = [];
		$headerParams = [];
		$httpBody     = '';
		$multipart    = false;

		// header params
		if ( $x_api_key !== null ) {
			$headerParams['x-api-key'] = ObjectSerializer::toHeaderValue( $x_api_key );
		}
		// header params
		if ( $x_app_api_key !== null ) {
			$headerParams['x-app-api-key'] = ObjectSerializer::toHeaderValue( $x_app_api_key );
		}
		// header params
		if ( $accept_language !== null ) {
			$headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue( $accept_language );
		}

		// path params
		if ( $workflow_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'workflowID' . '}',
				ObjectSerializer::toPathValue( $workflow_id ),
				$resourcePath
			);
		}
		// path params
		if ( $status_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'statusID' . '}',
				ObjectSerializer::toPathValue( $status_id ),
				$resourcePath
			);
		}
		// path params
		if ( $destination_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'destinationID' . '}',
				ObjectSerializer::toPathValue( $destination_id ),
				$resourcePath
			);
		}

		// body params
		$_tempBody = null;

		if ( $multipart ) {
			$headers = $this->headerSelector->selectHeadersForMultipart(
				[ '*/*', 'application/json' ]
			);
		} else {
			$headers = $this->headerSelector->selectHeaders(
				[ '*/*', 'application/json' ],
				[]
			);
		}

		// for model (json/xml)
		if ( isset( $_tempBody ) ) {
			// $_tempBody is the method argument, if present
			$httpBody = $_tempBody;
			// \stdClass has no __toString(), so we should encode it manually
			if ( $httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $httpBody );
			}
		} elseif ( count( $formParams ) > 0 ) {
			if ( $multipart ) {
				$multipartContents = [];
				foreach ( $formParams as $formParamName => $formParamValue ) {
					$multipartContents[] = [
						'name'     => $formParamName,
						'contents' => $formParamValue,
					];
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream( $multipartContents );

			} elseif ( $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $formParams );

			} else {
				// for HTTP post (form)
				$httpBody = \GuzzleHttp\Psr7\build_query( $formParams );
			}
		}

		$defaultHeaders = [];
		if ( $this->config->getUserAgent() ) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$query = \GuzzleHttp\Psr7\build_query( $queryParams );
		return new Request(
			'DELETE',
			$this->config->getHost() . $resourcePath . ( $query ? "?{$query}" : '' ),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation deleteOneWorkstepUsingDELETE
	 *
	 * Delete one Applied Status in a specified Workflow
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  string $x_api_key x_api_key (optional)
	 * @param  string $x_app_api_key x_app_api_key (optional)
	 * @param  string $accept_language accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return \Swagger\Client\Model\API1ResponseMessage
	 */
	public function deleteOneWorkstepUsingDELETE( $workflow_id, $status_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		list($response) = $this->deleteOneWorkstepUsingDELETEWithHttpInfo( $workflow_id, $status_id, $x_api_key, $x_app_api_key, $accept_language );
		return $response;
	}

	/**
	 * Operation deleteOneWorkstepUsingDELETEWithHttpInfo
	 *
	 * Delete one Applied Status in a specified Workflow
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return array of \Swagger\Client\Model\API1ResponseMessage, HTTP status code, HTTP response headers (array of strings)
	 */
	public function deleteOneWorkstepUsingDELETEWithHttpInfo( $workflow_id, $status_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1ResponseMessage';
		$request    = $this->deleteOneWorkstepUsingDELETERequest( $workflow_id, $status_id, $x_api_key, $x_app_api_key, $accept_language );

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send( $request, $options );
			} catch ( RequestException $e ) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					$e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
				);
			}

			$statusCode = $response->getStatusCode();

			if ( $statusCode < 200 || $statusCode > 299 ) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						$request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					$response->getBody()
				);
			}

			$responseBody = $response->getBody();
			if ( $returnType === '\SplFileObject' ) {
				$content = $responseBody; //stream goes to serializer
			} else {
				$content = $responseBody->getContents();
				if ( $returnType !== 'string' ) {
					$content = json_decode( $content );
				}
			}

			return [
				ObjectSerializer::deserialize( $content, $returnType, [] ),
				$response->getStatusCode(),
				$response->getHeaders(),
			];

		} catch ( ApiException $e ) {
			switch ( $e->getCode() ) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\Swagger\Client\Model\API1ResponseMessage',
						$e->getResponseHeaders()
					);
					$e->setResponseObject( $data );
					break;
			}
			throw $e;
		}
	}

	/**
	 * Operation deleteOneWorkstepUsingDELETEAsync
	 *
	 * Delete one Applied Status in a specified Workflow
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteOneWorkstepUsingDELETEAsync( $workflow_id, $status_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		return $this->deleteOneWorkstepUsingDELETEAsyncWithHttpInfo( $workflow_id, $status_id, $x_api_key, $x_app_api_key, $accept_language )
			->then(
				function ( $response ) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation deleteOneWorkstepUsingDELETEAsyncWithHttpInfo
	 *
	 * Delete one Applied Status in a specified Workflow
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function deleteOneWorkstepUsingDELETEAsyncWithHttpInfo( $workflow_id, $status_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1ResponseMessage';
		$request    = $this->deleteOneWorkstepUsingDELETERequest( $workflow_id, $status_id, $x_api_key, $x_app_api_key, $accept_language );

		return $this->client
			->sendAsync( $request, $this->createHttpClientOption() )
			->then(
				function ( $response ) use ( $returnType ) {
					$responseBody = $response->getBody();
					if ( $returnType === '\SplFileObject' ) {
						$content = $responseBody; //stream goes to serializer
					} else {
						$content = $responseBody->getContents();
						if ( $returnType !== 'string' ) {
							$content = json_decode( $content );
						}
					}

					return [
						ObjectSerializer::deserialize( $content, $returnType, [] ),
						$response->getStatusCode(),
						$response->getHeaders(),
					];
				},
				function ( $exception ) {
					$response   = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						$response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'deleteOneWorkstepUsingDELETE'
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	protected function deleteOneWorkstepUsingDELETERequest( $workflow_id, $status_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		// verify the required parameter 'workflow_id' is set
		if ( $workflow_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $workflow_id when calling deleteOneWorkstepUsingDELETE'
			);
		}
		// verify the required parameter 'status_id' is set
		if ( $status_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $status_id when calling deleteOneWorkstepUsingDELETE'
			);
		}

		$resourcePath = '/1/workflow/{workflowID}/status/{statusID}';
		$formParams   = [];
		$queryParams  = [];
		$headerParams = [];
		$httpBody     = '';
		$multipart    = false;

		// header params
		if ( $x_api_key !== null ) {
			$headerParams['x-api-key'] = ObjectSerializer::toHeaderValue( $x_api_key );
		}
		// header params
		if ( $x_app_api_key !== null ) {
			$headerParams['x-app-api-key'] = ObjectSerializer::toHeaderValue( $x_app_api_key );
		}
		// header params
		if ( $accept_language !== null ) {
			$headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue( $accept_language );
		}

		// path params
		if ( $workflow_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'workflowID' . '}',
				ObjectSerializer::toPathValue( $workflow_id ),
				$resourcePath
			);
		}
		// path params
		if ( $status_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'statusID' . '}',
				ObjectSerializer::toPathValue( $status_id ),
				$resourcePath
			);
		}

		// body params
		$_tempBody = null;

		if ( $multipart ) {
			$headers = $this->headerSelector->selectHeadersForMultipart(
				[ '*/*', 'application/json' ]
			);
		} else {
			$headers = $this->headerSelector->selectHeaders(
				[ '*/*', 'application/json' ],
				[]
			);
		}

		// for model (json/xml)
		if ( isset( $_tempBody ) ) {
			// $_tempBody is the method argument, if present
			$httpBody = $_tempBody;
			// \stdClass has no __toString(), so we should encode it manually
			if ( $httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $httpBody );
			}
		} elseif ( count( $formParams ) > 0 ) {
			if ( $multipart ) {
				$multipartContents = [];
				foreach ( $formParams as $formParamName => $formParamValue ) {
					$multipartContents[] = [
						'name'     => $formParamName,
						'contents' => $formParamValue,
					];
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream( $multipartContents );

			} elseif ( $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $formParams );

			} else {
				// for HTTP post (form)
				$httpBody = \GuzzleHttp\Psr7\build_query( $formParams );
			}
		}

		$defaultHeaders = [];
		if ( $this->config->getUserAgent() ) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$query = \GuzzleHttp\Psr7\build_query( $queryParams );
		return new Request(
			'DELETE',
			$this->config->getHost() . $resourcePath . ( $query ? "?{$query}" : '' ),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation fetchAllWorkflowsUsingGET
	 *
	 * Fetch all available Workflow objects
	 *
	 * @param  bool $minimal minimal (optional, default to false)
	 * @param  int $page_number pageNumber (optional, default to 1)
	 * @param  int $page_size pageSize (optional, default to 100)
	 * @param  string[] $order_by orderBy (optional, default to name asc)
	 * @param  string $x_api_key x_api_key (optional)
	 * @param  string $x_app_api_key x_app_api_key (optional)
	 * @param  string $accept_language accept_language (optional)
	 * @param  \DateTime $if_modified_since if_modified_since (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return \Swagger\Client\Model\API1ResultListResponseWorkflowV1TO_
	 */
	public function fetchAllWorkflowsUsingGET( $minimal = 'false', $page_number = '1', $page_size = '100', $order_by = 'name asc', $x_api_key = null, $x_app_api_key = null, $accept_language = null, $if_modified_since = null ) {
		list($response) = $this->fetchAllWorkflowsUsingGETWithHttpInfo( $minimal, $page_number, $page_size, $order_by, $x_api_key, $x_app_api_key, $accept_language, $if_modified_since );
		return $response;
	}

	/**
	 * Operation fetchAllWorkflowsUsingGETWithHttpInfo
	 *
	 * Fetch all available Workflow objects
	 *
	 * @param  bool $minimal minimal (optional, default to false)
	 * @param  int $page_number pageNumber (optional, default to 1)
	 * @param  int $page_size pageSize (optional, default to 100)
	 * @param  string[] $order_by orderBy (optional, default to name asc)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 * @param  \DateTime $if_modified_since (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return array of \Swagger\Client\Model\API1ResultListResponseWorkflowV1TO_, HTTP status code, HTTP response headers (array of strings)
	 */
	public function fetchAllWorkflowsUsingGETWithHttpInfo( $minimal = 'false', $page_number = '1', $page_size = '100', $order_by = 'name asc', $x_api_key = null, $x_app_api_key = null, $accept_language = null, $if_modified_since = null ) {
		$returnType = '\Swagger\Client\Model\API1ResultListResponseWorkflowV1TO_';
		$request    = $this->fetchAllWorkflowsUsingGETRequest( $minimal, $page_number, $page_size, $order_by, $x_api_key, $x_app_api_key, $accept_language, $if_modified_since );

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send( $request, $options );
			} catch ( RequestException $e ) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					$e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
				);
			}

			$statusCode = $response->getStatusCode();

			if ( $statusCode < 200 || $statusCode > 299 ) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						$request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					$response->getBody()
				);
			}

			$responseBody = $response->getBody();
			if ( $returnType === '\SplFileObject' ) {
				$content = $responseBody; //stream goes to serializer
			} else {
				$content = $responseBody->getContents();
				if ( $returnType !== 'string' ) {
					$content = json_decode( $content );
				}
			}

			return [
				ObjectSerializer::deserialize( $content, $returnType, [] ),
				$response->getStatusCode(),
				$response->getHeaders(),
			];

		} catch ( ApiException $e ) {
			switch ( $e->getCode() ) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\Swagger\Client\Model\API1ResultListResponseWorkflowV1TO_',
						$e->getResponseHeaders()
					);
					$e->setResponseObject( $data );
					break;
			}
			throw $e;
		}
	}

	/**
	 * Operation fetchAllWorkflowsUsingGETAsync
	 *
	 * Fetch all available Workflow objects
	 *
	 * @param  bool $minimal minimal (optional, default to false)
	 * @param  int $page_number pageNumber (optional, default to 1)
	 * @param  int $page_size pageSize (optional, default to 100)
	 * @param  string[] $order_by orderBy (optional, default to name asc)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 * @param  \DateTime $if_modified_since (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function fetchAllWorkflowsUsingGETAsync( $minimal = 'false', $page_number = '1', $page_size = '100', $order_by = 'name asc', $x_api_key = null, $x_app_api_key = null, $accept_language = null, $if_modified_since = null ) {
		return $this->fetchAllWorkflowsUsingGETAsyncWithHttpInfo( $minimal, $page_number, $page_size, $order_by, $x_api_key, $x_app_api_key, $accept_language, $if_modified_since )
			->then(
				function ( $response ) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation fetchAllWorkflowsUsingGETAsyncWithHttpInfo
	 *
	 * Fetch all available Workflow objects
	 *
	 * @param  bool $minimal minimal (optional, default to false)
	 * @param  int $page_number pageNumber (optional, default to 1)
	 * @param  int $page_size pageSize (optional, default to 100)
	 * @param  string[] $order_by orderBy (optional, default to name asc)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 * @param  \DateTime $if_modified_since (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function fetchAllWorkflowsUsingGETAsyncWithHttpInfo( $minimal = 'false', $page_number = '1', $page_size = '100', $order_by = 'name asc', $x_api_key = null, $x_app_api_key = null, $accept_language = null, $if_modified_since = null ) {
		$returnType = '\Swagger\Client\Model\API1ResultListResponseWorkflowV1TO_';
		$request    = $this->fetchAllWorkflowsUsingGETRequest( $minimal, $page_number, $page_size, $order_by, $x_api_key, $x_app_api_key, $accept_language, $if_modified_since );

		return $this->client
			->sendAsync( $request, $this->createHttpClientOption() )
			->then(
				function ( $response ) use ( $returnType ) {
					$responseBody = $response->getBody();
					if ( $returnType === '\SplFileObject' ) {
						$content = $responseBody; //stream goes to serializer
					} else {
						$content = $responseBody->getContents();
						if ( $returnType !== 'string' ) {
							$content = json_decode( $content );
						}
					}

					return [
						ObjectSerializer::deserialize( $content, $returnType, [] ),
						$response->getStatusCode(),
						$response->getHeaders(),
					];
				},
				function ( $exception ) {
					$response   = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						$response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'fetchAllWorkflowsUsingGET'
	 *
	 * @param  bool $minimal minimal (optional, default to false)
	 * @param  int $page_number pageNumber (optional, default to 1)
	 * @param  int $page_size pageSize (optional, default to 100)
	 * @param  string[] $order_by orderBy (optional, default to name asc)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 * @param  \DateTime $if_modified_since (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	protected function fetchAllWorkflowsUsingGETRequest( $minimal = 'false', $page_number = '1', $page_size = '100', $order_by = 'name asc', $x_api_key = null, $x_app_api_key = null, $accept_language = null, $if_modified_since = null ) {

		$resourcePath = '/1/workflow';
		$formParams   = [];
		$queryParams  = [];
		$headerParams = [];
		$httpBody     = '';
		$multipart    = false;

		// query params
		if ( $minimal !== null ) {
			$queryParams['minimal'] = ObjectSerializer::toQueryValue( $minimal );
		}
		// query params
		if ( $page_number !== null ) {
			$queryParams['pageNumber'] = ObjectSerializer::toQueryValue( $page_number );
		}
		// query params
		if ( $page_size !== null ) {
			$queryParams['pageSize'] = ObjectSerializer::toQueryValue( $page_size );
		}
		// query params
		if ( is_array( $order_by ) ) {
			$order_by = ObjectSerializer::serializeCollection( $order_by, 'multi', true );
		}
		if ( $order_by !== null ) {
			$queryParams['orderBy'] = ObjectSerializer::toQueryValue( $order_by );
		}
		// header params
		if ( $x_api_key !== null ) {
			$headerParams['x-api-key'] = ObjectSerializer::toHeaderValue( $x_api_key );
		}
		// header params
		if ( $x_app_api_key !== null ) {
			$headerParams['x-app-api-key'] = ObjectSerializer::toHeaderValue( $x_app_api_key );
		}
		// header params
		if ( $accept_language !== null ) {
			$headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue( $accept_language );
		}
		// header params
		if ( $if_modified_since !== null ) {
			$headerParams['If-Modified-Since'] = ObjectSerializer::toHeaderValue( $if_modified_since );
		}

		// body params
		$_tempBody = null;

		if ( $multipart ) {
			$headers = $this->headerSelector->selectHeadersForMultipart(
				[ '*/*', 'application/json' ]
			);
		} else {
			$headers = $this->headerSelector->selectHeaders(
				[ '*/*', 'application/json' ],
				[]
			);
		}

		// for model (json/xml)
		if ( isset( $_tempBody ) ) {
			// $_tempBody is the method argument, if present
			$httpBody = $_tempBody;
			// \stdClass has no __toString(), so we should encode it manually
			if ( $httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $httpBody );
			}
		} elseif ( count( $formParams ) > 0 ) {
			if ( $multipart ) {
				$multipartContents = [];
				foreach ( $formParams as $formParamName => $formParamValue ) {
					$multipartContents[] = [
						'name'     => $formParamName,
						'contents' => $formParamValue,
					];
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream( $multipartContents );

			} elseif ( $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $formParams );

			} else {
				// for HTTP post (form)
				$httpBody = \GuzzleHttp\Psr7\build_query( $formParams );
			}
		}

		$defaultHeaders = [];
		if ( $this->config->getUserAgent() ) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$query = \GuzzleHttp\Psr7\build_query( $queryParams );
		return new Request(
			'GET',
			$this->config->getHost() . $resourcePath . ( $query ? "?{$query}" : '' ),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation fetchAppliedStatusesOfWorkflowUsingGET
	 *
	 * Fetch the Applied Status objects that belong to a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  bool $minimal minimal (optional, default to false)
	 * @param  string $x_api_key x_api_key (optional)
	 * @param  string $x_app_api_key x_app_api_key (optional)
	 * @param  string $accept_language accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return \Swagger\Client\Model\API1ResultListResponseAppliedStatusV1TO_
	 */
	public function fetchAppliedStatusesOfWorkflowUsingGET( $workflow_id, $minimal = 'false', $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		list($response) = $this->fetchAppliedStatusesOfWorkflowUsingGETWithHttpInfo( $workflow_id, $minimal, $x_api_key, $x_app_api_key, $accept_language );
		return $response;
	}

	/**
	 * Operation fetchAppliedStatusesOfWorkflowUsingGETWithHttpInfo
	 *
	 * Fetch the Applied Status objects that belong to a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  bool $minimal minimal (optional, default to false)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return array of \Swagger\Client\Model\API1ResultListResponseAppliedStatusV1TO_, HTTP status code, HTTP response headers (array of strings)
	 */
	public function fetchAppliedStatusesOfWorkflowUsingGETWithHttpInfo( $workflow_id, $minimal = 'false', $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1ResultListResponseAppliedStatusV1TO_';
		$request    = $this->fetchAppliedStatusesOfWorkflowUsingGETRequest( $workflow_id, $minimal, $x_api_key, $x_app_api_key, $accept_language );

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send( $request, $options );
			} catch ( RequestException $e ) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					$e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
				);
			}

			$statusCode = $response->getStatusCode();

			if ( $statusCode < 200 || $statusCode > 299 ) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						$request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					$response->getBody()
				);
			}

			$responseBody = $response->getBody();
			if ( $returnType === '\SplFileObject' ) {
				$content = $responseBody; //stream goes to serializer
			} else {
				$content = $responseBody->getContents();
				if ( $returnType !== 'string' ) {
					$content = json_decode( $content );
				}
			}

			return [
				ObjectSerializer::deserialize( $content, $returnType, [] ),
				$response->getStatusCode(),
				$response->getHeaders(),
			];

		} catch ( ApiException $e ) {
			switch ( $e->getCode() ) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\Swagger\Client\Model\API1ResultListResponseAppliedStatusV1TO_',
						$e->getResponseHeaders()
					);
					$e->setResponseObject( $data );
					break;
			}
			throw $e;
		}
	}

	/**
	 * Operation fetchAppliedStatusesOfWorkflowUsingGETAsync
	 *
	 * Fetch the Applied Status objects that belong to a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  bool $minimal minimal (optional, default to false)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function fetchAppliedStatusesOfWorkflowUsingGETAsync( $workflow_id, $minimal = 'false', $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		return $this->fetchAppliedStatusesOfWorkflowUsingGETAsyncWithHttpInfo( $workflow_id, $minimal, $x_api_key, $x_app_api_key, $accept_language )
			->then(
				function ( $response ) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation fetchAppliedStatusesOfWorkflowUsingGETAsyncWithHttpInfo
	 *
	 * Fetch the Applied Status objects that belong to a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  bool $minimal minimal (optional, default to false)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function fetchAppliedStatusesOfWorkflowUsingGETAsyncWithHttpInfo( $workflow_id, $minimal = 'false', $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1ResultListResponseAppliedStatusV1TO_';
		$request    = $this->fetchAppliedStatusesOfWorkflowUsingGETRequest( $workflow_id, $minimal, $x_api_key, $x_app_api_key, $accept_language );

		return $this->client
			->sendAsync( $request, $this->createHttpClientOption() )
			->then(
				function ( $response ) use ( $returnType ) {
					$responseBody = $response->getBody();
					if ( $returnType === '\SplFileObject' ) {
						$content = $responseBody; //stream goes to serializer
					} else {
						$content = $responseBody->getContents();
						if ( $returnType !== 'string' ) {
							$content = json_decode( $content );
						}
					}

					return [
						ObjectSerializer::deserialize( $content, $returnType, [] ),
						$response->getStatusCode(),
						$response->getHeaders(),
					];
				},
				function ( $exception ) {
					$response   = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						$response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'fetchAppliedStatusesOfWorkflowUsingGET'
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  bool $minimal minimal (optional, default to false)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	protected function fetchAppliedStatusesOfWorkflowUsingGETRequest( $workflow_id, $minimal = 'false', $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		// verify the required parameter 'workflow_id' is set
		if ( $workflow_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $workflow_id when calling fetchAppliedStatusesOfWorkflowUsingGET'
			);
		}

		$resourcePath = '/1/workflow/{workflowID}/status';
		$formParams   = [];
		$queryParams  = [];
		$headerParams = [];
		$httpBody     = '';
		$multipart    = false;

		// query params
		if ( $minimal !== null ) {
			$queryParams['minimal'] = ObjectSerializer::toQueryValue( $minimal );
		}
		// header params
		if ( $x_api_key !== null ) {
			$headerParams['x-api-key'] = ObjectSerializer::toHeaderValue( $x_api_key );
		}
		// header params
		if ( $x_app_api_key !== null ) {
			$headerParams['x-app-api-key'] = ObjectSerializer::toHeaderValue( $x_app_api_key );
		}
		// header params
		if ( $accept_language !== null ) {
			$headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue( $accept_language );
		}

		// path params
		if ( $workflow_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'workflowID' . '}',
				ObjectSerializer::toPathValue( $workflow_id ),
				$resourcePath
			);
		}

		// body params
		$_tempBody = null;

		if ( $multipart ) {
			$headers = $this->headerSelector->selectHeadersForMultipart(
				[ '*/*', 'application/json' ]
			);
		} else {
			$headers = $this->headerSelector->selectHeaders(
				[ '*/*', 'application/json' ],
				[]
			);
		}

		// for model (json/xml)
		if ( isset( $_tempBody ) ) {
			// $_tempBody is the method argument, if present
			$httpBody = $_tempBody;
			// \stdClass has no __toString(), so we should encode it manually
			if ( $httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $httpBody );
			}
		} elseif ( count( $formParams ) > 0 ) {
			if ( $multipart ) {
				$multipartContents = [];
				foreach ( $formParams as $formParamName => $formParamValue ) {
					$multipartContents[] = [
						'name'     => $formParamName,
						'contents' => $formParamValue,
					];
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream( $multipartContents );

			} elseif ( $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $formParams );

			} else {
				// for HTTP post (form)
				$httpBody = \GuzzleHttp\Psr7\build_query( $formParams );
			}
		}

		$defaultHeaders = [];
		if ( $this->config->getUserAgent() ) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$query = \GuzzleHttp\Psr7\build_query( $queryParams );
		return new Request(
			'GET',
			$this->config->getHost() . $resourcePath . ( $query ? "?{$query}" : '' ),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation fetchOneAppliedStatusOfWorkflowUsingGET
	 *
	 * Fetch one Applied Status object that belongs to a specified Workflow, specified by Status ID.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  bool $minimal minimal (optional, default to false)
	 * @param  string $x_api_key x_api_key (optional)
	 * @param  string $x_app_api_key x_app_api_key (optional)
	 * @param  string $accept_language accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return \Swagger\Client\Model\API1SingleResultResponseAppliedStatusV1TO_
	 */
	public function fetchOneAppliedStatusOfWorkflowUsingGET( $workflow_id, $status_id, $minimal = 'false', $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		list($response) = $this->fetchOneAppliedStatusOfWorkflowUsingGETWithHttpInfo( $workflow_id, $status_id, $minimal, $x_api_key, $x_app_api_key, $accept_language );
		return $response;
	}

	/**
	 * Operation fetchOneAppliedStatusOfWorkflowUsingGETWithHttpInfo
	 *
	 * Fetch one Applied Status object that belongs to a specified Workflow, specified by Status ID.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  bool $minimal minimal (optional, default to false)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return array of \Swagger\Client\Model\API1SingleResultResponseAppliedStatusV1TO_, HTTP status code, HTTP response headers (array of strings)
	 */
	public function fetchOneAppliedStatusOfWorkflowUsingGETWithHttpInfo( $workflow_id, $status_id, $minimal = 'false', $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1SingleResultResponseAppliedStatusV1TO_';
		$request    = $this->fetchOneAppliedStatusOfWorkflowUsingGETRequest( $workflow_id, $status_id, $minimal, $x_api_key, $x_app_api_key, $accept_language );

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send( $request, $options );
			} catch ( RequestException $e ) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					$e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
				);
			}

			$statusCode = $response->getStatusCode();

			if ( $statusCode < 200 || $statusCode > 299 ) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						$request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					$response->getBody()
				);
			}

			$responseBody = $response->getBody();
			if ( $returnType === '\SplFileObject' ) {
				$content = $responseBody; //stream goes to serializer
			} else {
				$content = $responseBody->getContents();
				if ( $returnType !== 'string' ) {
					$content = json_decode( $content );
				}
			}

			return [
				ObjectSerializer::deserialize( $content, $returnType, [] ),
				$response->getStatusCode(),
				$response->getHeaders(),
			];

		} catch ( ApiException $e ) {
			switch ( $e->getCode() ) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\Swagger\Client\Model\API1SingleResultResponseAppliedStatusV1TO_',
						$e->getResponseHeaders()
					);
					$e->setResponseObject( $data );
					break;
			}
			throw $e;
		}
	}

	/**
	 * Operation fetchOneAppliedStatusOfWorkflowUsingGETAsync
	 *
	 * Fetch one Applied Status object that belongs to a specified Workflow, specified by Status ID.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  bool $minimal minimal (optional, default to false)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function fetchOneAppliedStatusOfWorkflowUsingGETAsync( $workflow_id, $status_id, $minimal = 'false', $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		return $this->fetchOneAppliedStatusOfWorkflowUsingGETAsyncWithHttpInfo( $workflow_id, $status_id, $minimal, $x_api_key, $x_app_api_key, $accept_language )
			->then(
				function ( $response ) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation fetchOneAppliedStatusOfWorkflowUsingGETAsyncWithHttpInfo
	 *
	 * Fetch one Applied Status object that belongs to a specified Workflow, specified by Status ID.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  bool $minimal minimal (optional, default to false)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function fetchOneAppliedStatusOfWorkflowUsingGETAsyncWithHttpInfo( $workflow_id, $status_id, $minimal = 'false', $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1SingleResultResponseAppliedStatusV1TO_';
		$request    = $this->fetchOneAppliedStatusOfWorkflowUsingGETRequest( $workflow_id, $status_id, $minimal, $x_api_key, $x_app_api_key, $accept_language );

		return $this->client
			->sendAsync( $request, $this->createHttpClientOption() )
			->then(
				function ( $response ) use ( $returnType ) {
					$responseBody = $response->getBody();
					if ( $returnType === '\SplFileObject' ) {
						$content = $responseBody; //stream goes to serializer
					} else {
						$content = $responseBody->getContents();
						if ( $returnType !== 'string' ) {
							$content = json_decode( $content );
						}
					}

					return [
						ObjectSerializer::deserialize( $content, $returnType, [] ),
						$response->getStatusCode(),
						$response->getHeaders(),
					];
				},
				function ( $exception ) {
					$response   = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						$response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'fetchOneAppliedStatusOfWorkflowUsingGET'
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  bool $minimal minimal (optional, default to false)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	protected function fetchOneAppliedStatusOfWorkflowUsingGETRequest( $workflow_id, $status_id, $minimal = 'false', $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		// verify the required parameter 'workflow_id' is set
		if ( $workflow_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $workflow_id when calling fetchOneAppliedStatusOfWorkflowUsingGET'
			);
		}
		// verify the required parameter 'status_id' is set
		if ( $status_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $status_id when calling fetchOneAppliedStatusOfWorkflowUsingGET'
			);
		}

		$resourcePath = '/1/workflow/{workflowID}/status/{statusID}';
		$formParams   = [];
		$queryParams  = [];
		$headerParams = [];
		$httpBody     = '';
		$multipart    = false;

		// query params
		if ( $minimal !== null ) {
			$queryParams['minimal'] = ObjectSerializer::toQueryValue( $minimal );
		}
		// header params
		if ( $x_api_key !== null ) {
			$headerParams['x-api-key'] = ObjectSerializer::toHeaderValue( $x_api_key );
		}
		// header params
		if ( $x_app_api_key !== null ) {
			$headerParams['x-app-api-key'] = ObjectSerializer::toHeaderValue( $x_app_api_key );
		}
		// header params
		if ( $accept_language !== null ) {
			$headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue( $accept_language );
		}

		// path params
		if ( $workflow_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'workflowID' . '}',
				ObjectSerializer::toPathValue( $workflow_id ),
				$resourcePath
			);
		}
		// path params
		if ( $status_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'statusID' . '}',
				ObjectSerializer::toPathValue( $status_id ),
				$resourcePath
			);
		}

		// body params
		$_tempBody = null;

		if ( $multipart ) {
			$headers = $this->headerSelector->selectHeadersForMultipart(
				[ '*/*', 'application/json' ]
			);
		} else {
			$headers = $this->headerSelector->selectHeaders(
				[ '*/*', 'application/json' ],
				[]
			);
		}

		// for model (json/xml)
		if ( isset( $_tempBody ) ) {
			// $_tempBody is the method argument, if present
			$httpBody = $_tempBody;
			// \stdClass has no __toString(), so we should encode it manually
			if ( $httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $httpBody );
			}
		} elseif ( count( $formParams ) > 0 ) {
			if ( $multipart ) {
				$multipartContents = [];
				foreach ( $formParams as $formParamName => $formParamValue ) {
					$multipartContents[] = [
						'name'     => $formParamName,
						'contents' => $formParamValue,
					];
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream( $multipartContents );

			} elseif ( $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $formParams );

			} else {
				// for HTTP post (form)
				$httpBody = \GuzzleHttp\Psr7\build_query( $formParams );
			}
		}

		$defaultHeaders = [];
		if ( $this->config->getUserAgent() ) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$query = \GuzzleHttp\Psr7\build_query( $queryParams );
		return new Request(
			'GET',
			$this->config->getHost() . $resourcePath . ( $query ? "?{$query}" : '' ),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation fetchOneTransitionUsingGET
	 *
	 * Fetch one Transition of one specified Applied Status of a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  int $destination_id destinationID (required)
	 * @param  string $x_api_key x_api_key (optional)
	 * @param  string $x_app_api_key x_app_api_key (optional)
	 * @param  string $accept_language accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return \Swagger\Client\Model\API1SingleResultResponseTransitionV1TO_
	 */
	public function fetchOneTransitionUsingGET( $workflow_id, $status_id, $destination_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		list($response) = $this->fetchOneTransitionUsingGETWithHttpInfo( $workflow_id, $status_id, $destination_id, $x_api_key, $x_app_api_key, $accept_language );
		return $response;
	}

	/**
	 * Operation fetchOneTransitionUsingGETWithHttpInfo
	 *
	 * Fetch one Transition of one specified Applied Status of a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  int $destination_id destinationID (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return array of \Swagger\Client\Model\API1SingleResultResponseTransitionV1TO_, HTTP status code, HTTP response headers (array of strings)
	 */
	public function fetchOneTransitionUsingGETWithHttpInfo( $workflow_id, $status_id, $destination_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1SingleResultResponseTransitionV1TO_';
		$request    = $this->fetchOneTransitionUsingGETRequest( $workflow_id, $status_id, $destination_id, $x_api_key, $x_app_api_key, $accept_language );

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send( $request, $options );
			} catch ( RequestException $e ) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					$e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
				);
			}

			$statusCode = $response->getStatusCode();

			if ( $statusCode < 200 || $statusCode > 299 ) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						$request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					$response->getBody()
				);
			}

			$responseBody = $response->getBody();
			if ( $returnType === '\SplFileObject' ) {
				$content = $responseBody; //stream goes to serializer
			} else {
				$content = $responseBody->getContents();
				if ( $returnType !== 'string' ) {
					$content = json_decode( $content );
				}
			}

			return [
				ObjectSerializer::deserialize( $content, $returnType, [] ),
				$response->getStatusCode(),
				$response->getHeaders(),
			];

		} catch ( ApiException $e ) {
			switch ( $e->getCode() ) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\Swagger\Client\Model\API1SingleResultResponseTransitionV1TO_',
						$e->getResponseHeaders()
					);
					$e->setResponseObject( $data );
					break;
			}
			throw $e;
		}
	}

	/**
	 * Operation fetchOneTransitionUsingGETAsync
	 *
	 * Fetch one Transition of one specified Applied Status of a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  int $destination_id destinationID (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function fetchOneTransitionUsingGETAsync( $workflow_id, $status_id, $destination_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		return $this->fetchOneTransitionUsingGETAsyncWithHttpInfo( $workflow_id, $status_id, $destination_id, $x_api_key, $x_app_api_key, $accept_language )
			->then(
				function ( $response ) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation fetchOneTransitionUsingGETAsyncWithHttpInfo
	 *
	 * Fetch one Transition of one specified Applied Status of a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  int $destination_id destinationID (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function fetchOneTransitionUsingGETAsyncWithHttpInfo( $workflow_id, $status_id, $destination_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1SingleResultResponseTransitionV1TO_';
		$request    = $this->fetchOneTransitionUsingGETRequest( $workflow_id, $status_id, $destination_id, $x_api_key, $x_app_api_key, $accept_language );

		return $this->client
			->sendAsync( $request, $this->createHttpClientOption() )
			->then(
				function ( $response ) use ( $returnType ) {
					$responseBody = $response->getBody();
					if ( $returnType === '\SplFileObject' ) {
						$content = $responseBody; //stream goes to serializer
					} else {
						$content = $responseBody->getContents();
						if ( $returnType !== 'string' ) {
							$content = json_decode( $content );
						}
					}

					return [
						ObjectSerializer::deserialize( $content, $returnType, [] ),
						$response->getStatusCode(),
						$response->getHeaders(),
					];
				},
				function ( $exception ) {
					$response   = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						$response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'fetchOneTransitionUsingGET'
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  int $destination_id destinationID (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	protected function fetchOneTransitionUsingGETRequest( $workflow_id, $status_id, $destination_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		// verify the required parameter 'workflow_id' is set
		if ( $workflow_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $workflow_id when calling fetchOneTransitionUsingGET'
			);
		}
		// verify the required parameter 'status_id' is set
		if ( $status_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $status_id when calling fetchOneTransitionUsingGET'
			);
		}
		// verify the required parameter 'destination_id' is set
		if ( $destination_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $destination_id when calling fetchOneTransitionUsingGET'
			);
		}

		$resourcePath = '/1/workflow/{workflowID}/status/{statusID}/transition/{destinationID}';
		$formParams   = [];
		$queryParams  = [];
		$headerParams = [];
		$httpBody     = '';
		$multipart    = false;

		// header params
		if ( $x_api_key !== null ) {
			$headerParams['x-api-key'] = ObjectSerializer::toHeaderValue( $x_api_key );
		}
		// header params
		if ( $x_app_api_key !== null ) {
			$headerParams['x-app-api-key'] = ObjectSerializer::toHeaderValue( $x_app_api_key );
		}
		// header params
		if ( $accept_language !== null ) {
			$headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue( $accept_language );
		}

		// path params
		if ( $workflow_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'workflowID' . '}',
				ObjectSerializer::toPathValue( $workflow_id ),
				$resourcePath
			);
		}
		// path params
		if ( $status_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'statusID' . '}',
				ObjectSerializer::toPathValue( $status_id ),
				$resourcePath
			);
		}
		// path params
		if ( $destination_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'destinationID' . '}',
				ObjectSerializer::toPathValue( $destination_id ),
				$resourcePath
			);
		}

		// body params
		$_tempBody = null;

		if ( $multipart ) {
			$headers = $this->headerSelector->selectHeadersForMultipart(
				[ '*/*', 'application/json' ]
			);
		} else {
			$headers = $this->headerSelector->selectHeaders(
				[ '*/*', 'application/json' ],
				[]
			);
		}

		// for model (json/xml)
		if ( isset( $_tempBody ) ) {
			// $_tempBody is the method argument, if present
			$httpBody = $_tempBody;
			// \stdClass has no __toString(), so we should encode it manually
			if ( $httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $httpBody );
			}
		} elseif ( count( $formParams ) > 0 ) {
			if ( $multipart ) {
				$multipartContents = [];
				foreach ( $formParams as $formParamName => $formParamValue ) {
					$multipartContents[] = [
						'name'     => $formParamName,
						'contents' => $formParamValue,
					];
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream( $multipartContents );

			} elseif ( $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $formParams );

			} else {
				// for HTTP post (form)
				$httpBody = \GuzzleHttp\Psr7\build_query( $formParams );
			}
		}

		$defaultHeaders = [];
		if ( $this->config->getUserAgent() ) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$query = \GuzzleHttp\Psr7\build_query( $queryParams );
		return new Request(
			'GET',
			$this->config->getHost() . $resourcePath . ( $query ? "?{$query}" : '' ),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation fetchOneWorkflowUsingGET
	 *
	 * Fetch a single Workflow object
	 *
	 * @param  int $id id (required)
	 * @param  string $x_api_key x_api_key (optional)
	 * @param  string $x_app_api_key x_app_api_key (optional)
	 * @param  string $accept_language accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return \Swagger\Client\Model\API1SingleResultResponseWorkflowV1TO_
	 */
	public function fetchOneWorkflowUsingGET( $id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		list($response) = $this->fetchOneWorkflowUsingGETWithHttpInfo( $id, $x_api_key, $x_app_api_key, $accept_language );
		return $response;
	}

	/**
	 * Operation fetchOneWorkflowUsingGETWithHttpInfo
	 *
	 * Fetch a single Workflow object
	 *
	 * @param  int $id id (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return array of \Swagger\Client\Model\API1SingleResultResponseWorkflowV1TO_, HTTP status code, HTTP response headers (array of strings)
	 */
	public function fetchOneWorkflowUsingGETWithHttpInfo( $id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1SingleResultResponseWorkflowV1TO_';
		$request    = $this->fetchOneWorkflowUsingGETRequest( $id, $x_api_key, $x_app_api_key, $accept_language );

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send( $request, $options );
			} catch ( RequestException $e ) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					$e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
				);
			}

			$statusCode = $response->getStatusCode();

			if ( $statusCode < 200 || $statusCode > 299 ) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						$request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					$response->getBody()
				);
			}

			$responseBody = $response->getBody();
			if ( $returnType === '\SplFileObject' ) {
				$content = $responseBody; //stream goes to serializer
			} else {
				$content = $responseBody->getContents();
				if ( $returnType !== 'string' ) {
					$content = json_decode( $content );
				}
			}

			return [
				ObjectSerializer::deserialize( $content, $returnType, [] ),
				$response->getStatusCode(),
				$response->getHeaders(),
			];

		} catch ( ApiException $e ) {
			switch ( $e->getCode() ) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\Swagger\Client\Model\API1SingleResultResponseWorkflowV1TO_',
						$e->getResponseHeaders()
					);
					$e->setResponseObject( $data );
					break;
			}
			throw $e;
		}
	}

	/**
	 * Operation fetchOneWorkflowUsingGETAsync
	 *
	 * Fetch a single Workflow object
	 *
	 * @param  int $id id (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function fetchOneWorkflowUsingGETAsync( $id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		return $this->fetchOneWorkflowUsingGETAsyncWithHttpInfo( $id, $x_api_key, $x_app_api_key, $accept_language )
			->then(
				function ( $response ) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation fetchOneWorkflowUsingGETAsyncWithHttpInfo
	 *
	 * Fetch a single Workflow object
	 *
	 * @param  int $id id (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function fetchOneWorkflowUsingGETAsyncWithHttpInfo( $id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1SingleResultResponseWorkflowV1TO_';
		$request    = $this->fetchOneWorkflowUsingGETRequest( $id, $x_api_key, $x_app_api_key, $accept_language );

		return $this->client
			->sendAsync( $request, $this->createHttpClientOption() )
			->then(
				function ( $response ) use ( $returnType ) {
					$responseBody = $response->getBody();
					if ( $returnType === '\SplFileObject' ) {
						$content = $responseBody; //stream goes to serializer
					} else {
						$content = $responseBody->getContents();
						if ( $returnType !== 'string' ) {
							$content = json_decode( $content );
						}
					}

					return [
						ObjectSerializer::deserialize( $content, $returnType, [] ),
						$response->getStatusCode(),
						$response->getHeaders(),
					];
				},
				function ( $exception ) {
					$response   = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						$response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'fetchOneWorkflowUsingGET'
	 *
	 * @param  int $id id (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	protected function fetchOneWorkflowUsingGETRequest( $id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		// verify the required parameter 'id' is set
		if ( $id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling fetchOneWorkflowUsingGET'
			);
		}

		$resourcePath = '/1/workflow/{id}';
		$formParams   = [];
		$queryParams  = [];
		$headerParams = [];
		$httpBody     = '';
		$multipart    = false;

		// header params
		if ( $x_api_key !== null ) {
			$headerParams['x-api-key'] = ObjectSerializer::toHeaderValue( $x_api_key );
		}
		// header params
		if ( $x_app_api_key !== null ) {
			$headerParams['x-app-api-key'] = ObjectSerializer::toHeaderValue( $x_app_api_key );
		}
		// header params
		if ( $accept_language !== null ) {
			$headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue( $accept_language );
		}

		// path params
		if ( $id !== null ) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue( $id ),
				$resourcePath
			);
		}

		// body params
		$_tempBody = null;

		if ( $multipart ) {
			$headers = $this->headerSelector->selectHeadersForMultipart(
				[ '*/*', 'application/json' ]
			);
		} else {
			$headers = $this->headerSelector->selectHeaders(
				[ '*/*', 'application/json' ],
				[]
			);
		}

		// for model (json/xml)
		if ( isset( $_tempBody ) ) {
			// $_tempBody is the method argument, if present
			$httpBody = $_tempBody;
			// \stdClass has no __toString(), so we should encode it manually
			if ( $httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $httpBody );
			}
		} elseif ( count( $formParams ) > 0 ) {
			if ( $multipart ) {
				$multipartContents = [];
				foreach ( $formParams as $formParamName => $formParamValue ) {
					$multipartContents[] = [
						'name'     => $formParamName,
						'contents' => $formParamValue,
					];
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream( $multipartContents );

			} elseif ( $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $formParams );

			} else {
				// for HTTP post (form)
				$httpBody = \GuzzleHttp\Psr7\build_query( $formParams );
			}
		}

		$defaultHeaders = [];
		if ( $this->config->getUserAgent() ) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$query = \GuzzleHttp\Psr7\build_query( $queryParams );
		return new Request(
			'GET',
			$this->config->getHost() . $resourcePath . ( $query ? "?{$query}" : '' ),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation fetchTransitionsOfOneAppliedStatusUsingGET
	 *
	 * Fetch the Transitions from one specified Applied Status of a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  string $x_api_key x_api_key (optional)
	 * @param  string $x_app_api_key x_app_api_key (optional)
	 * @param  string $accept_language accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return \Swagger\Client\Model\API1ResultListResponseTransitionV1TO_
	 */
	public function fetchTransitionsOfOneAppliedStatusUsingGET( $workflow_id, $status_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		list($response) = $this->fetchTransitionsOfOneAppliedStatusUsingGETWithHttpInfo( $workflow_id, $status_id, $x_api_key, $x_app_api_key, $accept_language );
		return $response;
	}

	/**
	 * Operation fetchTransitionsOfOneAppliedStatusUsingGETWithHttpInfo
	 *
	 * Fetch the Transitions from one specified Applied Status of a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return array of \Swagger\Client\Model\API1ResultListResponseTransitionV1TO_, HTTP status code, HTTP response headers (array of strings)
	 */
	public function fetchTransitionsOfOneAppliedStatusUsingGETWithHttpInfo( $workflow_id, $status_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1ResultListResponseTransitionV1TO_';
		$request    = $this->fetchTransitionsOfOneAppliedStatusUsingGETRequest( $workflow_id, $status_id, $x_api_key, $x_app_api_key, $accept_language );

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send( $request, $options );
			} catch ( RequestException $e ) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					$e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
				);
			}

			$statusCode = $response->getStatusCode();

			if ( $statusCode < 200 || $statusCode > 299 ) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						$request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					$response->getBody()
				);
			}

			$responseBody = $response->getBody();
			if ( $returnType === '\SplFileObject' ) {
				$content = $responseBody; //stream goes to serializer
			} else {
				$content = $responseBody->getContents();
				if ( $returnType !== 'string' ) {
					$content = json_decode( $content );
				}
			}

			return [
				ObjectSerializer::deserialize( $content, $returnType, [] ),
				$response->getStatusCode(),
				$response->getHeaders(),
			];

		} catch ( ApiException $e ) {
			switch ( $e->getCode() ) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\Swagger\Client\Model\API1ResultListResponseTransitionV1TO_',
						$e->getResponseHeaders()
					);
					$e->setResponseObject( $data );
					break;
			}
			throw $e;
		}
	}

	/**
	 * Operation fetchTransitionsOfOneAppliedStatusUsingGETAsync
	 *
	 * Fetch the Transitions from one specified Applied Status of a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function fetchTransitionsOfOneAppliedStatusUsingGETAsync( $workflow_id, $status_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		return $this->fetchTransitionsOfOneAppliedStatusUsingGETAsyncWithHttpInfo( $workflow_id, $status_id, $x_api_key, $x_app_api_key, $accept_language )
			->then(
				function ( $response ) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation fetchTransitionsOfOneAppliedStatusUsingGETAsyncWithHttpInfo
	 *
	 * Fetch the Transitions from one specified Applied Status of a specified Workflow.
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function fetchTransitionsOfOneAppliedStatusUsingGETAsyncWithHttpInfo( $workflow_id, $status_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1ResultListResponseTransitionV1TO_';
		$request    = $this->fetchTransitionsOfOneAppliedStatusUsingGETRequest( $workflow_id, $status_id, $x_api_key, $x_app_api_key, $accept_language );

		return $this->client
			->sendAsync( $request, $this->createHttpClientOption() )
			->then(
				function ( $response ) use ( $returnType ) {
					$responseBody = $response->getBody();
					if ( $returnType === '\SplFileObject' ) {
						$content = $responseBody; //stream goes to serializer
					} else {
						$content = $responseBody->getContents();
						if ( $returnType !== 'string' ) {
							$content = json_decode( $content );
						}
					}

					return [
						ObjectSerializer::deserialize( $content, $returnType, [] ),
						$response->getStatusCode(),
						$response->getHeaders(),
					];
				},
				function ( $exception ) {
					$response   = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						$response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'fetchTransitionsOfOneAppliedStatusUsingGET'
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	protected function fetchTransitionsOfOneAppliedStatusUsingGETRequest( $workflow_id, $status_id, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		// verify the required parameter 'workflow_id' is set
		if ( $workflow_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $workflow_id when calling fetchTransitionsOfOneAppliedStatusUsingGET'
			);
		}
		// verify the required parameter 'status_id' is set
		if ( $status_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $status_id when calling fetchTransitionsOfOneAppliedStatusUsingGET'
			);
		}

		$resourcePath = '/1/workflow/{workflowID}/status/{statusID}/transition';
		$formParams   = [];
		$queryParams  = [];
		$headerParams = [];
		$httpBody     = '';
		$multipart    = false;

		// header params
		if ( $x_api_key !== null ) {
			$headerParams['x-api-key'] = ObjectSerializer::toHeaderValue( $x_api_key );
		}
		// header params
		if ( $x_app_api_key !== null ) {
			$headerParams['x-app-api-key'] = ObjectSerializer::toHeaderValue( $x_app_api_key );
		}
		// header params
		if ( $accept_language !== null ) {
			$headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue( $accept_language );
		}

		// path params
		if ( $workflow_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'workflowID' . '}',
				ObjectSerializer::toPathValue( $workflow_id ),
				$resourcePath
			);
		}
		// path params
		if ( $status_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'statusID' . '}',
				ObjectSerializer::toPathValue( $status_id ),
				$resourcePath
			);
		}

		// body params
		$_tempBody = null;

		if ( $multipart ) {
			$headers = $this->headerSelector->selectHeadersForMultipart(
				[ '*/*', 'application/json' ]
			);
		} else {
			$headers = $this->headerSelector->selectHeaders(
				[ '*/*', 'application/json' ],
				[]
			);
		}

		// for model (json/xml)
		if ( isset( $_tempBody ) ) {
			// $_tempBody is the method argument, if present
			$httpBody = $_tempBody;
			// \stdClass has no __toString(), so we should encode it manually
			if ( $httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $httpBody );
			}
		} elseif ( count( $formParams ) > 0 ) {
			if ( $multipart ) {
				$multipartContents = [];
				foreach ( $formParams as $formParamName => $formParamValue ) {
					$multipartContents[] = [
						'name'     => $formParamName,
						'contents' => $formParamValue,
					];
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream( $multipartContents );

			} elseif ( $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $formParams );

			} else {
				// for HTTP post (form)
				$httpBody = \GuzzleHttp\Psr7\build_query( $formParams );
			}
		}

		$defaultHeaders = [];
		if ( $this->config->getUserAgent() ) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$query = \GuzzleHttp\Psr7\build_query( $queryParams );
		return new Request(
			'GET',
			$this->config->getHost() . $resourcePath . ( $query ? "?{$query}" : '' ),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation updateOneWorkflowUsingPUT
	 *
	 * Update one Workflow
	 *
	 * @param  int $id id (required)
	 * @param  \Swagger\Client\Model\WorkflowV1TO $updated_workflow updatedWorkflow (required)
	 * @param  string $x_api_key x_api_key (optional)
	 * @param  string $x_app_api_key x_app_api_key (optional)
	 * @param  string $accept_language accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return \Swagger\Client\Model\API1SingleResultResponseWorkflowV1TO_
	 */
	public function updateOneWorkflowUsingPUT( $id, $updated_workflow, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		list($response) = $this->updateOneWorkflowUsingPUTWithHttpInfo( $id, $updated_workflow, $x_api_key, $x_app_api_key, $accept_language );
		return $response;
	}

	/**
	 * Operation updateOneWorkflowUsingPUTWithHttpInfo
	 *
	 * Update one Workflow
	 *
	 * @param  int $id id (required)
	 * @param  \Swagger\Client\Model\WorkflowV1TO $updated_workflow updatedWorkflow (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return array of \Swagger\Client\Model\API1SingleResultResponseWorkflowV1TO_, HTTP status code, HTTP response headers (array of strings)
	 */
	public function updateOneWorkflowUsingPUTWithHttpInfo( $id, $updated_workflow, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1SingleResultResponseWorkflowV1TO_';
		$request    = $this->updateOneWorkflowUsingPUTRequest( $id, $updated_workflow, $x_api_key, $x_app_api_key, $accept_language );

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send( $request, $options );
			} catch ( RequestException $e ) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					$e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
				);
			}

			$statusCode = $response->getStatusCode();

			if ( $statusCode < 200 || $statusCode > 299 ) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						$request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					$response->getBody()
				);
			}

			$responseBody = $response->getBody();
			if ( $returnType === '\SplFileObject' ) {
				$content = $responseBody; //stream goes to serializer
			} else {
				$content = $responseBody->getContents();
				if ( $returnType !== 'string' ) {
					$content = json_decode( $content );
				}
			}

			return [
				ObjectSerializer::deserialize( $content, $returnType, [] ),
				$response->getStatusCode(),
				$response->getHeaders(),
			];

		} catch ( ApiException $e ) {
			switch ( $e->getCode() ) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\Swagger\Client\Model\API1SingleResultResponseWorkflowV1TO_',
						$e->getResponseHeaders()
					);
					$e->setResponseObject( $data );
					break;
			}
			throw $e;
		}
	}

	/**
	 * Operation updateOneWorkflowUsingPUTAsync
	 *
	 * Update one Workflow
	 *
	 * @param  int $id id (required)
	 * @param  \Swagger\Client\Model\WorkflowV1TO $updated_workflow updatedWorkflow (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateOneWorkflowUsingPUTAsync( $id, $updated_workflow, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		return $this->updateOneWorkflowUsingPUTAsyncWithHttpInfo( $id, $updated_workflow, $x_api_key, $x_app_api_key, $accept_language )
			->then(
				function ( $response ) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation updateOneWorkflowUsingPUTAsyncWithHttpInfo
	 *
	 * Update one Workflow
	 *
	 * @param  int $id id (required)
	 * @param  \Swagger\Client\Model\WorkflowV1TO $updated_workflow updatedWorkflow (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateOneWorkflowUsingPUTAsyncWithHttpInfo( $id, $updated_workflow, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1SingleResultResponseWorkflowV1TO_';
		$request    = $this->updateOneWorkflowUsingPUTRequest( $id, $updated_workflow, $x_api_key, $x_app_api_key, $accept_language );

		return $this->client
			->sendAsync( $request, $this->createHttpClientOption() )
			->then(
				function ( $response ) use ( $returnType ) {
					$responseBody = $response->getBody();
					if ( $returnType === '\SplFileObject' ) {
						$content = $responseBody; //stream goes to serializer
					} else {
						$content = $responseBody->getContents();
						if ( $returnType !== 'string' ) {
							$content = json_decode( $content );
						}
					}

					return [
						ObjectSerializer::deserialize( $content, $returnType, [] ),
						$response->getStatusCode(),
						$response->getHeaders(),
					];
				},
				function ( $exception ) {
					$response   = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						$response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'updateOneWorkflowUsingPUT'
	 *
	 * @param  int $id id (required)
	 * @param  \Swagger\Client\Model\WorkflowV1TO $updated_workflow updatedWorkflow (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	protected function updateOneWorkflowUsingPUTRequest( $id, $updated_workflow, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		// verify the required parameter 'id' is set
		if ( $id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $id when calling updateOneWorkflowUsingPUT'
			);
		}
		// verify the required parameter 'updated_workflow' is set
		if ( $updated_workflow === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $updated_workflow when calling updateOneWorkflowUsingPUT'
			);
		}

		$resourcePath = '/1/workflow/{id}';
		$formParams   = [];
		$queryParams  = [];
		$headerParams = [];
		$httpBody     = '';
		$multipart    = false;

		// header params
		if ( $x_api_key !== null ) {
			$headerParams['x-api-key'] = ObjectSerializer::toHeaderValue( $x_api_key );
		}
		// header params
		if ( $x_app_api_key !== null ) {
			$headerParams['x-app-api-key'] = ObjectSerializer::toHeaderValue( $x_app_api_key );
		}
		// header params
		if ( $accept_language !== null ) {
			$headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue( $accept_language );
		}

		// path params
		if ( $id !== null ) {
			$resourcePath = str_replace(
				'{' . 'id' . '}',
				ObjectSerializer::toPathValue( $id ),
				$resourcePath
			);
		}

		// body params
		$_tempBody = null;
		if ( isset( $updated_workflow ) ) {
			$_tempBody = $updated_workflow;
		}

		if ( $multipart ) {
			$headers = $this->headerSelector->selectHeadersForMultipart(
				[ '*/*', 'application/json' ]
			);
		} else {
			$headers = $this->headerSelector->selectHeaders(
				[ '*/*', 'application/json' ],
				[ 'application/json' ]
			);
		}

		// for model (json/xml)
		if ( isset( $_tempBody ) ) {
			// $_tempBody is the method argument, if present
			$httpBody = $_tempBody;
			// \stdClass has no __toString(), so we should encode it manually
			if ( $httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $httpBody );
			}
		} elseif ( count( $formParams ) > 0 ) {
			if ( $multipart ) {
				$multipartContents = [];
				foreach ( $formParams as $formParamName => $formParamValue ) {
					$multipartContents[] = [
						'name'     => $formParamName,
						'contents' => $formParamValue,
					];
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream( $multipartContents );

			} elseif ( $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $formParams );

			} else {
				// for HTTP post (form)
				$httpBody = \GuzzleHttp\Psr7\build_query( $formParams );
			}
		}

		$defaultHeaders = [];
		if ( $this->config->getUserAgent() ) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$query = \GuzzleHttp\Psr7\build_query( $queryParams );
		return new Request(
			'PUT',
			$this->config->getHost() . $resourcePath . ( $query ? "?{$query}" : '' ),
			$headers,
			$httpBody
		);
	}

	/**
	 * Operation updateOneWorkstepUsingPUT
	 *
	 * Update one Applied Status in a specified Workflow
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  \Swagger\Client\Model\AppliedStatusV1TO $incoming_workstep incomingWorkstep (required)
	 * @param  string $x_api_key x_api_key (optional)
	 * @param  string $x_app_api_key x_app_api_key (optional)
	 * @param  string $accept_language accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return \Swagger\Client\Model\API1SingleResultResponseAppliedStatusV1TO_
	 */
	public function updateOneWorkstepUsingPUT( $workflow_id, $status_id, $incoming_workstep, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		list($response) = $this->updateOneWorkstepUsingPUTWithHttpInfo( $workflow_id, $status_id, $incoming_workstep, $x_api_key, $x_app_api_key, $accept_language );
		return $response;
	}

	/**
	 * Operation updateOneWorkstepUsingPUTWithHttpInfo
	 *
	 * Update one Applied Status in a specified Workflow
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  \Swagger\Client\Model\AppliedStatusV1TO $incoming_workstep incomingWorkstep (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \Swagger\Client\ApiException on non-2xx response
	 * @throws \InvalidArgumentException
	 * @return array of \Swagger\Client\Model\API1SingleResultResponseAppliedStatusV1TO_, HTTP status code, HTTP response headers (array of strings)
	 */
	public function updateOneWorkstepUsingPUTWithHttpInfo( $workflow_id, $status_id, $incoming_workstep, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1SingleResultResponseAppliedStatusV1TO_';
		$request    = $this->updateOneWorkstepUsingPUTRequest( $workflow_id, $status_id, $incoming_workstep, $x_api_key, $x_app_api_key, $accept_language );

		try {
			$options = $this->createHttpClientOption();
			try {
				$response = $this->client->send( $request, $options );
			} catch ( RequestException $e ) {
				throw new ApiException(
					"[{$e->getCode()}] {$e->getMessage()}",
					$e->getCode(),
					$e->getResponse() ? $e->getResponse()->getHeaders() : null,
					$e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
				);
			}

			$statusCode = $response->getStatusCode();

			if ( $statusCode < 200 || $statusCode > 299 ) {
				throw new ApiException(
					sprintf(
						'[%d] Error connecting to the API (%s)',
						$statusCode,
						$request->getUri()
					),
					$statusCode,
					$response->getHeaders(),
					$response->getBody()
				);
			}

			$responseBody = $response->getBody();
			if ( $returnType === '\SplFileObject' ) {
				$content = $responseBody; //stream goes to serializer
			} else {
				$content = $responseBody->getContents();
				if ( $returnType !== 'string' ) {
					$content = json_decode( $content );
				}
			}

			return [
				ObjectSerializer::deserialize( $content, $returnType, [] ),
				$response->getStatusCode(),
				$response->getHeaders(),
			];

		} catch ( ApiException $e ) {
			switch ( $e->getCode() ) {
				case 200:
					$data = ObjectSerializer::deserialize(
						$e->getResponseBody(),
						'\Swagger\Client\Model\API1SingleResultResponseAppliedStatusV1TO_',
						$e->getResponseHeaders()
					);
					$e->setResponseObject( $data );
					break;
			}
			throw $e;
		}
	}

	/**
	 * Operation updateOneWorkstepUsingPUTAsync
	 *
	 * Update one Applied Status in a specified Workflow
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  \Swagger\Client\Model\AppliedStatusV1TO $incoming_workstep incomingWorkstep (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateOneWorkstepUsingPUTAsync( $workflow_id, $status_id, $incoming_workstep, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		return $this->updateOneWorkstepUsingPUTAsyncWithHttpInfo( $workflow_id, $status_id, $incoming_workstep, $x_api_key, $x_app_api_key, $accept_language )
			->then(
				function ( $response ) {
					return $response[0];
				}
			);
	}

	/**
	 * Operation updateOneWorkstepUsingPUTAsyncWithHttpInfo
	 *
	 * Update one Applied Status in a specified Workflow
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  \Swagger\Client\Model\AppliedStatusV1TO $incoming_workstep incomingWorkstep (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Promise\PromiseInterface
	 */
	public function updateOneWorkstepUsingPUTAsyncWithHttpInfo( $workflow_id, $status_id, $incoming_workstep, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		$returnType = '\Swagger\Client\Model\API1SingleResultResponseAppliedStatusV1TO_';
		$request    = $this->updateOneWorkstepUsingPUTRequest( $workflow_id, $status_id, $incoming_workstep, $x_api_key, $x_app_api_key, $accept_language );

		return $this->client
			->sendAsync( $request, $this->createHttpClientOption() )
			->then(
				function ( $response ) use ( $returnType ) {
					$responseBody = $response->getBody();
					if ( $returnType === '\SplFileObject' ) {
						$content = $responseBody; //stream goes to serializer
					} else {
						$content = $responseBody->getContents();
						if ( $returnType !== 'string' ) {
							$content = json_decode( $content );
						}
					}

					return [
						ObjectSerializer::deserialize( $content, $returnType, [] ),
						$response->getStatusCode(),
						$response->getHeaders(),
					];
				},
				function ( $exception ) {
					$response   = $exception->getResponse();
					$statusCode = $response->getStatusCode();
					throw new ApiException(
						sprintf(
							'[%d] Error connecting to the API (%s)',
							$statusCode,
							$exception->getRequest()->getUri()
						),
						$statusCode,
						$response->getHeaders(),
						$response->getBody()
					);
				}
			);
	}

	/**
	 * Create request for operation 'updateOneWorkstepUsingPUT'
	 *
	 * @param  int $workflow_id workflowID (required)
	 * @param  int $status_id statusID (required)
	 * @param  \Swagger\Client\Model\AppliedStatusV1TO $incoming_workstep incomingWorkstep (required)
	 * @param  string $x_api_key (optional)
	 * @param  string $x_app_api_key (optional)
	 * @param  string $accept_language (optional)
	 *
	 * @throws \InvalidArgumentException
	 * @return \GuzzleHttp\Psr7\Request
	 */
	protected function updateOneWorkstepUsingPUTRequest( $workflow_id, $status_id, $incoming_workstep, $x_api_key = null, $x_app_api_key = null, $accept_language = null ) {
		// verify the required parameter 'workflow_id' is set
		if ( $workflow_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $workflow_id when calling updateOneWorkstepUsingPUT'
			);
		}
		// verify the required parameter 'status_id' is set
		if ( $status_id === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $status_id when calling updateOneWorkstepUsingPUT'
			);
		}
		// verify the required parameter 'incoming_workstep' is set
		if ( $incoming_workstep === null ) {
			throw new \InvalidArgumentException(
				'Missing the required parameter $incoming_workstep when calling updateOneWorkstepUsingPUT'
			);
		}

		$resourcePath = '/1/workflow/{workflowID}/status/{statusID}';
		$formParams   = [];
		$queryParams  = [];
		$headerParams = [];
		$httpBody     = '';
		$multipart    = false;

		// header params
		if ( $x_api_key !== null ) {
			$headerParams['x-api-key'] = ObjectSerializer::toHeaderValue( $x_api_key );
		}
		// header params
		if ( $x_app_api_key !== null ) {
			$headerParams['x-app-api-key'] = ObjectSerializer::toHeaderValue( $x_app_api_key );
		}
		// header params
		if ( $accept_language !== null ) {
			$headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue( $accept_language );
		}

		// path params
		if ( $workflow_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'workflowID' . '}',
				ObjectSerializer::toPathValue( $workflow_id ),
				$resourcePath
			);
		}
		// path params
		if ( $status_id !== null ) {
			$resourcePath = str_replace(
				'{' . 'statusID' . '}',
				ObjectSerializer::toPathValue( $status_id ),
				$resourcePath
			);
		}

		// body params
		$_tempBody = null;
		if ( isset( $incoming_workstep ) ) {
			$_tempBody = $incoming_workstep;
		}

		if ( $multipart ) {
			$headers = $this->headerSelector->selectHeadersForMultipart(
				[ '*/*', 'application/json' ]
			);
		} else {
			$headers = $this->headerSelector->selectHeaders(
				[ '*/*', 'application/json' ],
				[ 'application/json' ]
			);
		}

		// for model (json/xml)
		if ( isset( $_tempBody ) ) {
			// $_tempBody is the method argument, if present
			$httpBody = $_tempBody;
			// \stdClass has no __toString(), so we should encode it manually
			if ( $httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $httpBody );
			}
		} elseif ( count( $formParams ) > 0 ) {
			if ( $multipart ) {
				$multipartContents = [];
				foreach ( $formParams as $formParamName => $formParamValue ) {
					$multipartContents[] = [
						'name'     => $formParamName,
						'contents' => $formParamValue,
					];
				}
				// for HTTP post (form)
				$httpBody = new MultipartStream( $multipartContents );

			} elseif ( $headers['Content-Type'] === 'application/json' ) {
				$httpBody = \GuzzleHttp\json_encode( $formParams );

			} else {
				// for HTTP post (form)
				$httpBody = \GuzzleHttp\Psr7\build_query( $formParams );
			}
		}

		$defaultHeaders = [];
		if ( $this->config->getUserAgent() ) {
			$defaultHeaders['User-Agent'] = $this->config->getUserAgent();
		}

		$headers = array_merge(
			$defaultHeaders,
			$headerParams,
			$headers
		);

		$query = \GuzzleHttp\Psr7\build_query( $queryParams );
		return new Request(
			'PUT',
			$this->config->getHost() . $resourcePath . ( $query ? "?{$query}" : '' ),
			$headers,
			$httpBody
		);
	}

	/**
	 * Create http client option
	 *
	 * @throws \RuntimeException on file opening failure
	 * @return array of http client options
	 */
	protected function createHttpClientOption() {
		$options = [];
		if ( $this->config->getDebug() ) {
			$options[ RequestOptions::DEBUG ] = fopen( $this->config->getDebugFile(), 'a' );
			if ( ! $options[ RequestOptions::DEBUG ] ) {
				throw new \RuntimeException( 'Failed to open the debug file: ' . $this->config->getDebugFile() );
			}
		}

		return $options;
	}
}
